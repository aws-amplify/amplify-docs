---
title: Using Amplify with CDK
description: How to use existing Amplify resources in a CDK project
---

When using Amplify, you may run into a scenario when you need a feature that the Amplify CLI does not yet support. As an escape hatch, you can either configure [custom resources](~/cli/usage/customcf.md) with Amplify or manage resources outside of Amplify using another cloudformation provider.

In this guide you'll learn how to extend an Amplify project with CDK by importing existing Amplify resources into a CDK project. You'll then learn how to programmatically create a CDK exports file similar to the Amplify exports file for consumption by your client-side project.

### Getting started

This guide will walk you through adding authentication using the Amplify CLI and then building a GraphQL API that references and uses this authentication service as an authentication and authorization provider.

## Creating the Amplify app

The first step will be to initialize an Amplify app and create a new authentication service.

<amplify-callout>

If you already have an authentication service created using the Amplify CLI, you can jump to [Creating the CDK project](#creating-the-cdk-project)

</amplify-callout>

```sh
amplify init # Initializing the Amplify project - choose all defaults
amplify add auth # Adding authentication

? Do you want to use default authentication and security configuration? Default configuration 
? How do you want users to be able to sign in when using your Cognito User Pool? Username
? Do you want to configure advanced settings? No, I am done. 

amplify push --y # Deploying the Amplify back end

## Creating the CDK project

Next, create a new folder called __cdk-backend__ and initialize a new CDK project within that folder.

```sh
mkdir cdk-backend
cd cdk-backend
cdk init --language=typescript
```
<amplify-callout>

If this is your first time using the CDK CLI, you can install it with `npm install -g aws-cdk` and learn more about the `cdk` command [in the CDK docs](https://docs.aws.amazon.com/cdk/latest/guide/cli.html).

</amplify-callout>
Next, install the necessary CDK dependencies for AWS AppSync, AWS Lambda, Amazon Cognito, and Amazon DynamoDB:

```sh
npm install @aws-cdk/aws-appsync @aws-cdk/aws-cognito @aws-cdk/aws-dynamodb @aws-cdk/aws-lambda
```

### Consuming the authentication service with CDK

Next, open __lib/cdk-backend-stack.ts__ and update with the following code.

<amplify-callout>

Note that `<your-user-pool-id>` will be the user pool ID generated by the Amplify cli and will be available in __src/aws-exports.js__ as the `aws_user_pools_id` property.

</amplify-callout>

```js
import * as cdk from '@aws-cdk/core';
import * as appsync from '@aws-cdk/aws-appsync';
import * as cognito from '@aws-cdk/aws-cognito';
import * as lambda from '@aws-cdk/aws-lambda';
import * as dynamodb from '@aws-cdk/aws-dynamodb';

export class CdkBackendStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);
  
    /* Consumes the user pool created by Amplify CLI */
    const userPool = cognito.UserPool.fromUserPoolId(
      this,
      'amplify-user-pool',
      <your-user-pool-id>
    )

    /* Creates the AppSync API using the User Pool from Amplify */
    const api = new appsync.GraphqlApi(this, 'Api', {
      name: 'cdk-blog-api',
      schema: appsync.Schema.fromAsset('graphql/schema.graphql'),
      authorizationConfig: {
        defaultAuthorization: {
          authorizationType: appsync.AuthorizationType.API_KEY,
          apiKeyConfig: {
            expires: cdk.Expiration.after(cdk.Duration.days(365))
          }
        },
        additionalAuthorizationModes: [
          {
            authorizationType: appsync.AuthorizationType.USER_POOL,
            userPoolConfig: {
              userPool
            }
          }
        ]
      },
      xrayEnabled: true,
    });

    /* Prints out the GraphQL API endpoint */
    new cdk.CfnOutput(this, "aws_appsync_graphqlEndpoint", {
      value: api.graphqlUrl
    });

    /* Prints out the GraphQL API API Key */
    new cdk.CfnOutput(this, "aws_appsync_apiKey", {
      value: api.apiKey || ''
    });

    /* Creates the Lambda function that the API will use as a data source */
    const blogLambda = new lambda.Function(this, 'AppSyncBlogHandler', {
      runtime: lambda.Runtime.NODEJS_12_X,
      handler: 'main.handler',
      code: lambda.Code.fromAsset('lambda-fns'),
      memorySize: 1024
    });
    
    /* Adds the Lambda Function as a data source */
    const lambdaDs = api.addLambdaDataSource('lambdaDatasource', blogLambda);

    /* Creates a GraphQL resolver for creating a new post */
    lambdaDs.createResolver({
      typeName: "Mutation",
      fieldName: "createPost"
    });

    /* Creates a GraphQL resolver for querying posts */
    lambdaDs.createResolver({
      typeName: "Query",
      fieldName: "listPosts"
    });

    /* Creates a DynamoDB table for saving the data */
    const postTable = new dynamodb.Table(this, 'CDKPostTable', {
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      partitionKey: {
        name: 'id',
        type: dynamodb.AttributeType.STRING,
      },
    });

    /* Enables IAM access to the DynamoDB table from the Lambda function */
    postTable.grantFullAccess(blogLambda)
    
    /* Creates an environment variable for consumption by the Lambda function */
    blogLambda.addEnvironment('POST_TABLE', postTable.tableName);

  }
}
```

### Creating the GraphQL schema

Create a __graphql__ folder in __cdk-backend__ and add a GraphQL schema at __cdk-backend/graphql/schema.graphql__

```graphql
type Post @aws_cognito_user_pools @aws_api_key {
  id: ID!
  title: String!
  content: String!
  username: String!
}

input PostInput {
  id: ID!
  title: String!
  content: String!
}

type Mutation {
  createPost(post: PostInput!): Post @aws_cognito_user_pools
}

type Query {
  listPosts: [Post] @aws_cognito_user_pools @aws_api_key
}
```

Next, create a folder called __lambda-fns__ in __cdk-backend__ and add a file called __main.ts__ within that folder with the following code:

```ts
const AWS = require('aws-sdk');
const docClient = new AWS.DynamoDB.DocumentClient();

type Post = {
  id: string;
  title: string;
  content: string;
  username: string;
}

type AppSyncEvent = {
  info: {
    fieldName: string
  },
  arguments: {
    postId: string,
    post: Post
  },
  identity: {
    sub : string;
    username : string;
  }
}

async function createPost(post: Post) {
    const params = {
        TableName: process.env.POST_TABLE,
        Item: post
    }
    try {
        await docClient.put(params).promise();
        return post;
    } catch (err) {
        console.log('DynamoDB error: ', err);
        return null;
    }
}

async function listPosts() {
    const params = {
        TableName: process.env.POST_TABLE,
    }
    try {
        const data = await docClient.scan(params).promise()
        return data.Items
    } catch (err) {
        console.log('DynamoDB error: ', err)
        return null
    }
}

exports.handler = async (event:AppSyncEvent) => {
    const username = event.identity?.username;
    switch (event.info.fieldName) {
        case "createPost":
            return await createPost({ ...event.arguments.post, username });
        case "listPosts":
            return await listPosts();
        default:
            return null;
    }
}
```

### Deploying the CDK back end & generating the exports file

Now that the CDK back end is set up, you can now deploy it. When deploying a CDK back end, you can pipe any `CfnOutput` properties into a JSON file by using the `--outputs-file` flag.

Next, deploy the infrastructure and pipe the CDK outputs file one directory up so it will be at the same level as the Amplify project:

```sh
npm run build && cdk deploy --outputs-file ../cdk-exports.json
```

<amplify-callout>

You can also use the shorthand -O to pipe output: `cdk deploy -O ../cdk-exports.json`

</amplify-callout>

<inline-fragment platform="js" src="~/guides/cdk/fragments/js/importing-configuration.md"></inline-fragment> 
